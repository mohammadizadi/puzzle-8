<documentations>
سورس این برنامه شامل 6 فایل است
.فایل های end.txt و start.txt ورودی های برنامه میباشند که end حالت پایانی و start حالت شرو را تایین میکند.



//توضیحات مربوط به فایل classes

.فایل classes.py شامل یک کلاس برای ساختار درخت میباشد .
این کلاس شامل 5 متغییر به شرح ذیل میباشد:
state:حالت پازل در این گره از درخن میباشد.
parent:گره والد این گره را در خود ذخیره میکند.
depth:عمق مسیر را در خود ذخیره میکند.
operator:نوع حرکتی که باعث بوجود آمدن این گره میشود را در خود ذخیره میکند مثلا right,left,...
fn:این مقدار در این برنامه در روش A* استفاده شده و برابر با مقادیر Gn + hn میباشد.برای سرعت بخشیدن به اجرای الگوریتم پس از حر بار محاسبه fn آن را دی این متغییر ذخیره میکنیم.



//توضیحات مربوط به logic.py

این برنامه شامل 4 روش برای حل پازل 8 میباشد
1:bfs
2:dfs(limited)
3:ids
4:A*
این فابل شامل منطق ابتدایی و سطحی برنامه (استفاده کردن از توابع مورد نیاز و گرفتن ورودی از کار بر و نمایش خروجی به کاربر) میباشد
در اول این فایل چند if وجود دارد که نوع الگوریتم درخواستی کاربر را مشخص میکند و تابع مورد نظر را فراخوانی مینماید
و در آخر خروجی برنامه را به کاربر نمایش میدهد




//توضیحات مربوط به functions.py

در این فایل توابه ما و در اصل منطق اصلی برنامه و الگوریتم های ما برنامه نویسی شده است.
 دو تابع readstart و readend حالت های شروع و پایان را از فایل میخوانند.
 تابع show_state یک state به عنوان ورودی میگیرد و آن را به صورت ماتریسی یا همان پازل نمایش میدهد.
 4 تابع move_up و move_down وmove_left و move_right یک ورودی state گرفته مکان (*) را پیدا مینماید و در صورت نداشتن محدودیت برای جابجایی آن را بنا به تابع فراخوانی شده جابجا میکند.
 تابه add_node مقدار های اولیه مورد نیاز برای ساختن یک شی از کلاس Node را میگیرد و آن را میسازد.
 تابه expand_node یک گره را به عنوان ورودی میپذیرد و آن را به هر 4 عمل بالا و پایین و... گسترش میدهد و نود های فرزندش را میسازد.

//الگوریتم ها
تابه bfs:
دو آرگومان حالت اولیه و حالت ثانویه را میگیرد.
الگوریتم جستجو اول سطح میباشد در ابتدا یک لیست به نام tree ایجاد کرده که بنا به الگوریتم از آن به عنوان یک صف استفاده میشود.
در ابتدا و قبل از while یک نود شروع میسازیم و در while  در ابتدا چک میکند که به جواب رسیده ایم یا خیر اگه رسیده بودیم قادر به نمایش دو نوع جواب میباشد اول این که حرکات را نمایش دهد مث right ,... و حالت دیگر این است که تمام state ها را تا رسیدن به گره اصلی ( از گره فعلی که جواب باشد ) برگرداند که در هر دو یک به یک از حالت جواب به parent رفته و متغیر مورد نظر را بر میگردانیم و ذخیره میکنیم.
و در ابتدا اگر جواب نبود و از if رد شد گره را گسترش میدهیم و دوباره به اول while بر میگردیم.


dfs(limited):
این الگوریتم 3 آرگومان به عنوان ورودی میگیرد که 2تای اولی حالت شرو و پایان میباشد و آخری محدودیت عمق است.
این الگوریتم همانند bfs کار میکند با این تفوت که در اینجا از صف به عنوان پشته استفاده میشود و با استفاده از جابجایی متغیر مقادیر جدید تولید شده را در اول لیست میریزیم و در آخر عمق را با یک if چک میکنیم که از limit رد نکنیم.


ids:
این الگوریتم همان ورودی های dfs را دریافت میکند و اصل منطق آن همان dfs است با ابن تفافت که عمق را از 0 شرو کرده و تا محدودیت تایین شده پیش میرویم و هر بار برای هر عمق تابه dfs را فرا خوانی میکنیم.



A*:
تا اینجا الگوریتم های استفاده شده نا آگاهانه بودند و ممکن بود خیلی از جواب های ممکنه پیدا نشوند یا خیلی زمان زیادی برای حل آنها صرف شود ولی این الگوریتم آگاهانه است و مشکلات گفته شده در این الگوریتم به شدت کاهش میابد.
توضیح الگوریتم را با دو تابع h , fn شرو میکنیم.
تابه h یا همان هیوریستیک حالت فعلی و حالت پایانی را به شکل ماتریس 2 بعدی در میاورد و با استفاده از تفاوت سطر و ستون این دو حالت ( حالت فعلی باید مثل حالت پایانی شود )برای هر عدد hn آن حالت را حساب کرده و بر میگرداند (از روش منهتن استفاده میشود ).
تابع fn , fn هر نود را با استفاده از عمق که به عنوان gn استفاده میشود و فراخوانی تابع h که همان hn میباشد و با جمع این دو fn را بر میگرداند و همچنین در متغیر fn آن نود دخیره میکند.
حال وارد الگوریتم اصلی میشویم این الگوریت همانند قبلی ها یک صف تشکیل داده و نود اصلی را میسازد در ابتده اگر fn در متغیر نود ذخیره نشده بود و مقدار آن برابر -1 بود آن را حساب میکند در غیر این صورت خیر.
بعد به وسیله یک حلقه کوچکترین fn را در نود های صف پیدا کرده و آن را در current_node ریخته برای محاسبات بعدی .
در ادامه مثل الگوریتم های قبلی پک میکنیم که آیا به حالت پایان رسیدیم یا خیر.
اگه نرسیده بودیم نود فعلی که fn آن از همه کمتر بود را گسترش میدهیم .



(پایان)
مستند ساز و برنامه نویس : محمد ایزدی.
